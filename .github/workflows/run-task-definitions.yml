# This workflow will be run manually by QA after the deploy-extension-to-marketplace.yml workflow is run and AWS Marketplace listing is approved.

name: Run ECS task definitions after AWS Marketplace approval

on:
  workflow_dispatch:
    inputs:
      image_tag:
        description: "Liquibase Pro Docker image tag (full URI or tag)"
        required: true

permissions:
  id-token: write
  contents: read

jobs:
  run-core-tasks:
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      matrix:
        include:
          - family: version-command
            container_name: Liquibase-Pro
          - family: update-command-dynamodb
            container_name: Liquibase-Pro

    env:
      CLUSTER_NAME: aws-mp-test-cluster
      SUBNETS: subnet-e01f40ad,subnet-372ba268,subnet-a45ad6c2
      ECR_PREFIX: 709825985650.dkr.ecr.us-east-1.amazonaws.com/liquibase/liquibase/liquibasepro

    steps:
      - name: Show inputs
        run: |
          echo "IMAGE_TAG=${{ inputs.image_tag }}"
          echo "FAMILY=${{ matrix.family }}"
          echo "CONTAINER_NAME=${{ matrix.container_name }}"

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_MARKETPLACE_GITHUB_OIDC_ROLE_ARN_INFRASTRUCTURE }}
          aws-region: us-east-1
          role-session-name: AWSMarketplaceApprovalSession

      - name: Install jq
        run: sudo apt-get update && sudo apt-get install -y jq

      - name: Resolve IMAGE_URI (accept full URI or tag)
        id: resolve_image
        shell: bash
        run: |
          IMAGE_TAG="${{ inputs.image_tag }}"
          if [[ "$IMAGE_TAG" == *".amazonaws.com"* || "$IMAGE_TAG" == *".dkr.ecr."* ]]; then
            IMAGE_URI="$IMAGE_TAG"
          else
            IMAGE_URI="${ECR_PREFIX}:${IMAGE_TAG}"
          fi
          echo "image_uri=$IMAGE_URI" >> "$GITHUB_OUTPUT"

      - name: Build registerable task definition
        env:
          FAMILY: ${{ matrix.family }}
          CONTAINER_NAME: ${{ matrix.container_name }}
        run: |
          aws ecs describe-task-definition --task-definition "$FAMILY" --query taskDefinition > base.json
          jq --arg IMG "${{ steps.resolve_image.outputs.image_uri }}" --arg NAME "$CONTAINER_NAME" '
            .containerDefinitions |= (map(if .name == $NAME then .image = $IMG else . end))
          ' base.json > _tmp.json
          jq 'del(
                .taskDefinitionArn,
                .requiresAttributes,
                .compatibilities,
                .revision,
                .status,
                .registeredAt,
                .registeredBy,
                .deregisteredAt
              )' _tmp.json > task-def.json

      - name: Register new task definition
        id: register
        run: |
          aws ecs register-task-definition --cli-input-json file://task-def.json > reg.json
          TASK_DEF_ARN=$(jq -r '.taskDefinition.taskDefinitionArn' reg.json)
          echo "task_def_arn=$TASK_DEF_ARN" >> "$GITHUB_OUTPUT"

      - name: Run task
        id: run_task
        run: |
          aws ecs run-task \
            --cluster "$CLUSTER_NAME" \
            --launch-type FARGATE \
            --network-configuration "awsvpcConfiguration={subnets=[$SUBNETS],assignPublicIp=ENABLED}" \
            --task-definition "${{ steps.register.outputs.task_def_arn }}" \
            --count 1 > run.json
          TASK_ARN=$(jq -r '.tasks[0].taskArn' run.json)
          echo "task_arn=$TASK_ARN" >> "$GITHUB_OUTPUT"

      - name: Wait and check exit code
        run: |
          aws ecs wait tasks-stopped --cluster "$CLUSTER_NAME" --tasks "${{ steps.run_task.outputs.task_arn }}"
          aws ecs describe-tasks --cluster "$CLUSTER_NAME" --tasks "${{ steps.run_task.outputs.task_arn }}" > desc.json
          EXIT_CODE=$(jq -r '.tasks[0].containers[0].exitCode' desc.json)
          echo "Exit code: $EXIT_CODE"
          test "${EXIT_CODE}" = "0"


  run-dropall-task:
    runs-on: ubuntu-latest
    needs: run-core-tasks
      # run the job run-dropall-task only after successful completion of job run-core-tasks
    if: ${{ needs.run-core-tasks.result == 'success' && inputs.image_tag != '' }}
    env:
      CLUSTER_NAME: aws-mp-test-cluster
      SUBNETS: subnet-e01f40ad,subnet-372ba268,subnet-a45ad6c2

    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_MARKETPLACE_GITHUB_OIDC_ROLE_ARN_INFRASTRUCTURE }}
          aws-region: us-east-1
          role-session-name: AWSMarketplaceApprovalSession

      - name: Install jq
        run: sudo apt-get update && sudo apt-get install -y jq

      - name: Describe and prepare dropall task
        run: |
          aws ecs describe-task-definition --task-definition dropall-command --query taskDefinition > base.json
          jq 'del(
                .taskDefinitionArn,
                .requiresAttributes,
                .compatibilities,
                .revision,
                .status,
                .registeredAt,
                .registeredBy,
                .deregisteredAt
              )' base.json > task-def.json

      - name: Register new dropall revision
        id: register
        run: |
          aws ecs register-task-definition --cli-input-json file://task-def.json > reg.json
          TASK_DEF_ARN=$(jq -r '.taskDefinition.taskDefinitionArn' reg.json)
          echo "task_def_arn=$TASK_DEF_ARN" >> "$GITHUB_OUTPUT"

      - name: Run dropall task
        id: run_task
        run: |
          aws ecs run-task \
            --cluster "$CLUSTER_NAME" \
            --launch-type FARGATE \
            --network-configuration "awsvpcConfiguration={subnets=[$SUBNETS],assignPublicIp=ENABLED}" \
            --task-definition "${{ steps.register.outputs.task_def_arn }}" \
            --count 1 > run.json
          TASK_ARN=$(jq -r '.tasks[0].taskArn' run.json)
          echo "task_arn=$TASK_ARN" >> "$GITHUB_OUTPUT"

      - name: Wait and check exit code
        run: |
          aws ecs wait tasks-stopped --cluster "$CLUSTER_NAME" --tasks "${{ steps.run_task.outputs.task_arn }}"
          aws ecs describe-tasks --cluster "$CLUSTER_NAME" --tasks "${{ steps.run_task.outputs.task_arn }}" > desc.json
          EXIT_CODE=$(jq -r '.tasks[0].containers[0].exitCode' desc.json)
          echo "Exit code: $EXIT_CODE"
          test "${EXIT_CODE}" = "0"


  restrict-marketplace-listing:
    runs-on: ubuntu-latest
    needs: run-dropall-task
    if: ${{ needs.run-dropall-task.result == 'success' }}
    env:
      AWS_REGION: us-east-1
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Configure AWS credentials for vault access
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.LIQUIBASE_VAULT_OIDC_ROLE_ARN }}
          aws-region: us-east-1

      - name: Get secrets from vault
        id: vault-secrets
        uses: aws-actions/aws-secretsmanager-get-secrets@v2
        with:
          secret-ids: |
            ,/vault/liquibase
          parse-json-secrets: true

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ env.AWS_MP_GITHUB_OIDC_ROLE_ARN_AWS_LICENSE_SERVICE }}
          aws-region: us-east-1

      - name: Restrict AWS Marketplace listing
        env:
          PRODUCT_ID: ${{ env.PRODUCT_ID }}
        run: |
          chmod +x ./.github/utils/restrict-aws-mp-listing.sh
          ./.github/utils/restrict-aws-mp-listing.sh
